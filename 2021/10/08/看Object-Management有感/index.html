<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
        <link rel="shortcut icon" href="/ico.ico">
    
    
        <link rel="icon" type="image/png" sizes="16x16" href="/smallicon.png">
    
    
        <link rel="icon" type="image/png" sizes="32x32" href="/midicon.png">
    
    
        <link rel="apple-touch-icon" sizes="180x180" href="/ico.ico">
    
    
        <link rel="mask-icon" href="/ico.ico">
    


    <!-- meta -->


<title>看Object Management有感 | 南方真理会</title>


    <meta name="keywords" content="Uinty">




    <!-- OpenGraph -->
 
    <meta name="description" content="看了Catlike coding的教程，感觉有所收获，在这里记录一下. 对象的持久化对于一个预制件，我们可以使用Instantiate()来实例化。如 12345void Update () &amp;#123;	if (Input.GetKeyDown(createKey)) &amp;#123;		Instantiate(prefab);	&amp;#125;&amp;#125;  即当按下createKey所记录的键后，创">
<meta property="og:type" content="article">
<meta property="og:title" content="看Object Management有感">
<meta property="og:url" content="http://dh224.github.io/2021/10/08/%E7%9C%8BObject-Management%E6%9C%89%E6%84%9F/index.html">
<meta property="og:site_name" content="南方真理会">
<meta property="og:description" content="看了Catlike coding的教程，感觉有所收获，在这里记录一下. 对象的持久化对于一个预制件，我们可以使用Instantiate()来实例化。如 12345void Update () &amp;#123;	if (Input.GetKeyDown(createKey)) &amp;#123;		Instantiate(prefab);	&amp;#125;&amp;#125;  即当按下createKey所记录的键后，创">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://satt.oss-cn-hangzhou.aliyuncs.com/img/image-20211008182646614.png">
<meta property="article:published_time" content="2021-10-08T13:57:14.000Z">
<meta property="article:modified_time" content="2023-05-09T11:04:03.044Z">
<meta property="article:author" content="dh">
<meta property="article:tag" content="Uinty">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://satt.oss-cn-hangzhou.aliyuncs.com/img/image-20211008182646614.png">


    
<link rel="stylesheet" href="/style.css">
 

    
    
        <link rel="stylesheet" id="hl-default-theme" href="/css/highlight/default.css" media="none">
        
            <link rel="stylesheet" id="hl-dark-theme" href="/css/highlight/dark.css" media="none">
        
    

    
    

    
    
<link rel="stylesheet" href="/css/style/dark.css">

    
<script src="/js/darkmode.js"></script>



     

    <!-- custom head -->

<meta name="generator" content="Hexo 5.4.0"></head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">南方真理会</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">首页</a>
                
                    <a href="/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/archives/" class="navbar-menu button">归档</a>
                
            </div>
        
        
        

        
        
    <a href="javaScript:void(0);" id="btn-toggle-dark">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
    </a>


        

        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">首页</a>
                
                    <a href="/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/archives/" class="dropdown-menu button">归档</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        看Object Management有感
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2021/10/" class="post-meta__date button">2021-10-08</a>
        
 
        
    
    


 

 
    </div>
</div>


    <aside class="post-side">
        <div class="post-side__toc">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">对象的持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%81%E6%89%93%E5%BC%80%E3%80%81%E5%86%99%E5%85%A5%E5%92%8C%E8%AF%BB%E5%8F%96"><span class="toc-text">文件的路径、打开、写入和读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="toc-text">代码的抽象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E4%BD%93%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">物体的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E7%8A%B6%E5%B7%A5%E5%8E%82"><span class="toc-text">形状工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E5%BD%A2%E7%8A%B6%E5%92%8C%E6%9D%90%E8%B4%A8"><span class="toc-text">保存形状和材质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E9%A2%9C%E8%89%B2"><span class="toc-text">随机颜色</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%94%A8%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="toc-text">重用对象——对象池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%A7%E6%AF%81%E7%89%A9%E4%BD%93%E5%8F%8A%E4%BC%98%E5%8C%96"><span class="toc-text">摧毁物体及优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E7%94%9F%E6%88%90%E5%92%8C%E6%91%A7%E6%AF%81"><span class="toc-text">自动化生成和摧毁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0"><span class="toc-text">内存池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%9C%BA%E6%99%AF"><span class="toc-text">多场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%9C%BA%E6%99%AF%E7%BC%96%E8%BE%91"><span class="toc-text">多场景编辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%9C%BA%E6%99%AF%E5%88%87%E6%8D%A2"><span class="toc-text">多场景切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%8C%BA"><span class="toc-text">生成区</span></a></li></ol>
        </div>
    </aside>
    <a class="btn-toc button" id="btn-toc" tabindex="0">
        <svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg">
            <path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path>
        </svg>
    </a>
    <div class="toc-menus" id="toc-menus">
        <div class="toc-title">Article Directory</div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">对象的持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%81%E6%89%93%E5%BC%80%E3%80%81%E5%86%99%E5%85%A5%E5%92%8C%E8%AF%BB%E5%8F%96"><span class="toc-text">文件的路径、打开、写入和读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="toc-text">代码的抽象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E4%BD%93%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">物体的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E7%8A%B6%E5%B7%A5%E5%8E%82"><span class="toc-text">形状工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E5%BD%A2%E7%8A%B6%E5%92%8C%E6%9D%90%E8%B4%A8"><span class="toc-text">保存形状和材质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E9%A2%9C%E8%89%B2"><span class="toc-text">随机颜色</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%94%A8%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="toc-text">重用对象——对象池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%A7%E6%AF%81%E7%89%A9%E4%BD%93%E5%8F%8A%E4%BC%98%E5%8C%96"><span class="toc-text">摧毁物体及优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E7%94%9F%E6%88%90%E5%92%8C%E6%91%A7%E6%AF%81"><span class="toc-text">自动化生成和摧毁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0"><span class="toc-text">内存池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%9C%BA%E6%99%AF"><span class="toc-text">多场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%9C%BA%E6%99%AF%E7%BC%96%E8%BE%91"><span class="toc-text">多场景编辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%9C%BA%E6%99%AF%E5%88%87%E6%8D%A2"><span class="toc-text">多场景切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%8C%BA"><span class="toc-text">生成区</span></a></li></ol>
    </div>


<article class="post post__with-toc content-card">
    <div class="post__header">
    
        <div class="post-thumbnail" style="background-image: url('http://satt.oss-cn-hangzhou.aliyuncs.com/img/image-20211008182646614.png');"></div>
    

    <div class="post__expire" id="post-expired-notify">
        <p>
            This article was last updated on &lt;span id=&#34;expire-date&#34;&gt;&lt;/span&gt; days ago, the information described in the article may be outdated.
        </p>
    </div>
    <script>
        (() => {
            var update = Date.parse("2023-05-09"),
                date = new Date(),
                now = date.getTime(),
                expire = now - update,
                expire_days = Math.floor(expire/(24*3600*1000));
            if (expire_days >= 120) {
                document.querySelectorAll('#expire-date')[0].innerHTML = expire_days;
                document.querySelectorAll('#post-expired-notify')[0].style.display = 'block';
            }
        })();
    </script>
</div>
    <div class="post__content">
        <p>看了<a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/object-management/persisting-objects/">Catlike coding的教程</a>，感觉有所收获，在这里记录一下.</p>
<h2 id="对象的持久化"><a href="#对象的持久化" class="headerlink" title="对象的持久化"></a>对象的持久化</h2><p>对于一个预制件，我们可以使用Instantiate()来实例化。如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Update () &#123;</span><br><span class="line">	if (Input.GetKeyDown(createKey)) &#123;</span><br><span class="line">		Instantiate(prefab);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即当按下createKey所记录的键后，创建一个prefab。如果再用随机数修改这些prefab的localposition，那么我们就可以创建一系列随机的Cube。那么如何保存这些随机生成的？这就引出了本篇教程的主题，即对象的持久化。</p>
<h3 id="文件的路径、打开、写入和读取"><a href="#文件的路径、打开、写入和读取" class="headerlink" title="文件的路径、打开、写入和读取"></a>文件的路径、打开、写入和读取</h3><p>要想要保存这些游戏物体，最符合直觉的方式是将其数据保存在一个文件中，当我们需要加载这些预先保存的物体的时候，我们就读取这个文件，获得数据，随后生成物体。</p>
<p>所以，第一步就是要设定保存数据的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.IO;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class Game : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">	…</span><br><span class="line"></span><br><span class="line">	void Awake () &#123;</span><br><span class="line">		objects = new List&lt;Transform&gt;();</span><br><span class="line">		savePath = Path.Combine(Application.persistentDataPath, &quot;saveFile&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以用这种方式来设置用来保存文件的路径。由于C#的原因，我们在写入数据之前还需要对文件进行“OPEN”操作。我们可以用二进制来写数据。因此如下代码可用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void Save () &#123;</span><br><span class="line">	BinaryWriter writer =</span><br><span class="line">		new BinaryWriter(File.Open(savePath, FileMode.Create));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，由于c#的原因，我们还需要在文件打开和关闭之间进行异常判断，这在java里非常复杂，而C#为我们提供了好用的语法糖。即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Save () &#123;</span><br><span class="line">	using (</span><br><span class="line">		var writer = new BinaryWriter(File.Open(savePath, FileMode.Create))</span><br><span class="line">	) </span><br><span class="line">       &#123;</span><br><span class="line">          //todo</span><br><span class="line">           writer.Write(objects.Count);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在大括号中对writer进行操作。不用再写麻烦的try……catch。</p>
<p>……终于，在打开文件后，我们<em>终于</em>可以写数据了！接下去的代码平平无奇。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">writer.Write(objects.Count);</span><br><span class="line">for (int i = 0; i &lt; objects.Count; i++) &#123;</span><br><span class="line">	Transform t = objects[i];</span><br><span class="line">	writer.Write(t.localPosition.x);</span><br><span class="line">	writer.Write(t.localPosition.y);</span><br><span class="line">	writer.Write(t.localPosition.z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上的代码，我们写入了Cube的位置，但是没有记录他们的缩放和旋转，因此，读取后他们的角度是固定的。我们会在之后进行修改。</p>
<p><img src="http://satt.oss-cn-hangzhou.aliyuncs.com/img/image-20211008155824435.png" alt="image-20211008155824435"></p>
<p>接下去就是读取数据了。不过在记录读取数据之前，我们要明白，我们为啥不用Unity提供的BinaryFormatter来存储文件。教程的作者给出的答案是：我们这样做更加灵活和可理解。</p>
<p>读取数据的代码和存数据的代码类似。不赘。</p>
<p>总之，根据教程，我们实现了以下功能：</p>
<p>按C创建一个随机位置的方块，按N消除所有方块。按S将所有方块的位置信息保存在一个二进制文件中。按L读取文件，并重新创建方块。</p>
<p>接下去就是对于代码逻辑的优化。</p>
<h3 id="代码的抽象"><a href="#代码的抽象" class="headerlink" title="代码的抽象"></a>代码的抽象</h3><p>尽管我们实现了上述的功能，但是却不符合软件工程的高内聚低耦合的原则。我们不想在读取和加载的时候，都要多次调用write和read方法，我们也不想固定用二进制存储我们的数据。因此，我们需要抽象出Writer和Reader类，来帮助我们实现分离。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class GameDataWriter  </span><br><span class="line">&#123;</span><br><span class="line">    BinaryWriter writer;</span><br><span class="line">    public GameDataWriter(BinaryWriter writer)</span><br><span class="line">    &#123;</span><br><span class="line">        this.writer = writer;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Write(float value)</span><br><span class="line">    &#123;</span><br><span class="line">        writer.Write(value);</span><br><span class="line">    &#125;</span><br><span class="line">    public void Write(Quaternion value)</span><br><span class="line">    &#123;</span><br><span class="line">        writer.Write(value.x);</span><br><span class="line">        writer.Write(value.y);</span><br><span class="line">        writer.Write(value.z);</span><br><span class="line">        writer.Write(value.w);</span><br><span class="line">    &#125;</span><br><span class="line">    public void Write(Vector3 value)</span><br><span class="line">    &#123;</span><br><span class="line">        writer.Write(value.x);</span><br><span class="line">        writer.Write(value.y);</span><br><span class="line">        writer.Write(value.z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于writer和reader的代码过于雷同，这里只贴writer的部分。总之，我们将一些低级操作封装了起来。</p>
<p>接下去，我们要让我们的调用者来保存数据，而不是引入writer来做这件事。因此，我们还需要创建PersistableObjet类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class PersistableObject : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">	public void Save (GameDataWriter writer) &#123;</span><br><span class="line">		writer.Write(transform.localPosition);</span><br><span class="line">		writer.Write(transform.localRotation);</span><br><span class="line">		writer.Write(transform.localScale);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void Load (GameDataReader reader) &#123;</span><br><span class="line">		transform.localPosition = reader.ReadVector3();</span><br><span class="line">		transform.localRotation = reader.ReadQuaternion();</span><br><span class="line">		transform.localScale = reader.ReadVector3();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建这个类的目的是:对于需要持久化的物体，我们让这个物体继承PersistableObject类，就将这个（类）物体设置成持久化对象类型。它（们）获得了一些方便地接口。这样就可以方便（具体）地设置这类持久化物体需要保存的参数了。</p>
<p>有了PersistableObject类还不够，我们还需要创建PersistentStorage类来保存这类对象。理论上，对于不同类型的PersisitableObject类（如有必要），我们都需创建对应的PersistentStorage来操作这类对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">using System.IO;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class PersistentStorage : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">	string savePath;</span><br><span class="line"></span><br><span class="line">	void Awake () &#123;</span><br><span class="line">		savePath = Path.Combine(Application.persistentDataPath, &quot;saveFile&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void Save (PersistableObject o) &#123;</span><br><span class="line">		using (</span><br><span class="line">			var writer = new BinaryWriter(File.Open(savePath, FileMode.Create))</span><br><span class="line">		) &#123;</span><br><span class="line">			o.Save(new GameDataWriter(writer));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void Load (PersistableObject o) &#123;</span><br><span class="line">		using (</span><br><span class="line">			var reader = new BinaryReader(File.Open(savePath, FileMode.Open))</span><br><span class="line">		) &#123;</span><br><span class="line">			o.Load(new GameDataReader(reader));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再之后，我们重写一部分我们写好的代码。</p>
<p><img src="http://satt.oss-cn-hangzhou.aliyuncs.com/img/image-20211008161858119.png" alt="image-20211008161858119"></p>
<p>为了多次保存和读取，我们还需要让我们的脚本自身继承persistableObject类。为了方便操作，我们引入了stroage。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Game : PersistableObject &#123;</span><br><span class="line"></span><br><span class="line">	…</span><br><span class="line"></span><br><span class="line">	public PersistentStorage storage;</span><br><span class="line"></span><br><span class="line">	…</span><br><span class="line"></span><br><span class="line">	void Update () &#123;</span><br><span class="line">		if (Input.GetKeyDown(createKey)) &#123;</span><br><span class="line">			CreateObject();</span><br><span class="line">		&#125;</span><br><span class="line">		else if (Input.GetKeyDown(saveKey)) &#123;</span><br><span class="line">			storage.Save(this);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (Input.GetKeyDown(loadKey)) &#123;</span><br><span class="line">			BeginNewGame();</span><br><span class="line">			storage.Load(this);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前，如果我们按S保存，我们保存下来的是我们的Game脚本，这是没用的，我们还需要在Game脚本里重写load和save方法，即保存每一个创建出来的方块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void Save (GameDataWriter writer) &#123;</span><br><span class="line">	writer.Write(objects.Count);</span><br><span class="line">	for (int i = 0; i &lt; objects.Count; i++) &#123;</span><br><span class="line">		objects[i].Save(writer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public override void Load (GameDataReader reader) &#123;</span><br><span class="line">	int count = reader.ReadInt();</span><br><span class="line">	for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">		PersistableObject o = Instantiate(prefab);</span><br><span class="line">		o.Load(reader);</span><br><span class="line">		objects.Add(o);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此，我们完成了对于之前功能的抽象。</p>
<h2 id="物体的种类"><a href="#物体的种类" class="headerlink" title="物体的种类"></a>物体的种类</h2><h3 id="形状工厂"><a href="#形状工厂" class="headerlink" title="形状工厂"></a>形状工厂</h3><p>为了能让我们生成不同形状的物体，我们需要创建一个继承了PersistableObject类的Shape类。值得注意的是，由于我们之前的设置，persistableObject类和Shape类不能共存。</p>
<p>接下去，我们继续创建ShapeFactiory类。对于这个工厂，他的作用是交付形状实例。我们不需要让他设置位置、旋转和缩放。也不需要改变状态。因此它可以作为一个asset存在。实现的方法是继承ScriptableObject类.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[CreateAssetMenu]</span><br><span class="line">public class ShapeFactory : ScriptableObject &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用[CreateAssetMenu]标签可以让它出现在create里。</p>
<p><img src="http://satt.oss-cn-hangzhou.aliyuncs.com/img/image-20211008204206185.png" alt="image-20211008204206185"></p>
<p>在ShapeFactory类里，我们创建预制件。并且实现其交付功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Shape Get (int shapeId) &#123;</span><br><span class="line">	return Instantiate(prefabs[shapeId]);</span><br><span class="line">&#125;</span><br><span class="line">	public Shape GetRandom () &#123;</span><br><span class="line">	return Get(Random.Range(0, prefabs.Length));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时有个值得注意的点。产生随机形状的时候，代码中居然写的是0<del>prefabs.Length。我们都知道，实际上应该是0</del>prefabs.Length-1才对。这只是因为unity为他特意做了设置而已。为了能让ShapeFactory实现功能，我们还需要修改原来的一些代码，不赘。</p>
<h3 id="保存形状和材质"><a href="#保存形状和材质" class="headerlink" title="保存形状和材质"></a>保存形状和材质</h3><p>之前我们已经能够做到保存生成的cube。既然已经实现了生成不同形状的物体，那么势必要修改一下我们的存取了。</p>
<p>显然，为了知道当前物体的形状，我们必须要在Shape类里添加一个shapeId属性。理论上，这个属性应该是readonly的。但是，考虑到我们实现了形状工厂以及其他的抽象，我们必然要在其他地方设置物体的形状，因此我们需要添加get和set方法。并且，可以添加一条简单的if语句来判断形状是否正确分配了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int ShapeId &#123;</span><br><span class="line">	get &#123;</span><br><span class="line">		return shapeId;</span><br><span class="line">	&#125;</span><br><span class="line">	set &#123;</span><br><span class="line">		if (shapeId == 0) &#123;</span><br><span class="line">			shapeId = value;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			Debug.LogError(&quot;Not allowed to change shapeId.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处又是一个很细的点。由于默认值一开始设置的是0，而0有可能代表false。为了避免这种情况，我们将默认值设置为int的最小值。</p>
<p><img src="http://satt.oss-cn-hangzhou.aliyuncs.com/img/image-20211008205613493.png" alt="image-20211008205613493"></p>
<p>由于添加了形状属性。所以，我们保存的文件也需要增加这一部分。这与之前设置的存档起了冲突。</p>
<p>一个简单的想法是：添加version属性，用来判断不同版本的存档，便于我们读取。即，新版本支持读取旧版本的存档。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public override void Save (GameDataWriter writer) &#123;</span><br><span class="line">	writer.Write(saveVersion);</span><br><span class="line">	writer.Write(shapes.Count);</span><br><span class="line">	…</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public override void Load (GameDataReader reader) &#123;</span><br><span class="line">	int version = reader.ReadInt();</span><br><span class="line">	int count = reader.ReadInt();</span><br><span class="line">	…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处，教程用了一种相当巧妙的方法。由于原先存档的第一个int是物体的数量，那么必然&gt;=0。因此，我们在保存version的时候，可以将其反转正负号。当我们读取第一个数字后，若是正数，那么我们就能立刻判断出这是个老版本的存档。此处还添加了一个版本判断报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int version = reader.Version;</span><br><span class="line">if (version &gt; saveVersion)</span><br><span class="line">&#123;</span><br><span class="line">	Debug.LogError(&quot;Unsupported future save version &quot; + version);</span><br><span class="line">     return;</span><br><span class="line">&#125;</span><br><span class="line">int count = version &lt;= 0 ? -version : reader.ReadInt();</span><br></pre></td></tr></table></figure>

<p>当然，接下去还有一系列逻辑代码的修改，在教程里写的很清楚。</p>
<p>除了可以改变创建物体的形状，还可以修改创建物体的材质。不过方法与之类似。不赘述。</p>
<h3 id="随机颜色"><a href="#随机颜色" class="headerlink" title="随机颜色"></a>随机颜色</h3><p>为了创建随机颜色的物体。我们需要在Shape里创建新的字段，并增加set方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Color color;</span><br><span class="line"></span><br><span class="line">public void SetColor (Color color) &#123;</span><br><span class="line">	this.color = color;</span><br><span class="line">	GetComponent&lt;MeshRenderer&gt;().material.color = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且在之前的抽象类,GameDataWriter\reader里增加一个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void Write (Color value) &#123;</span><br><span class="line">	writer.Write(value.r);</span><br><span class="line">	writer.Write(value.g);</span><br><span class="line">	writer.Write(value.b);</span><br><span class="line">	writer.Write(value.a);</span><br><span class="line">&#125;</span><br><span class="line">	public Color ReadColor () &#123;</span><br><span class="line">		Color value;</span><br><span class="line">		value.r = reader.ReadSingle();</span><br><span class="line">		value.g = reader.ReadSingle();</span><br><span class="line">		value.b = reader.ReadSingle();</span><br><span class="line">		value.a = reader.ReadSingle();</span><br><span class="line">		return value;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>为了增加向后兼容的能力，即若打开旧版本存档，我们就要跳过存储颜色的部分。这部分教程里写的很清楚。</p>
<h2 id="重用对象——对象池"><a href="#重用对象——对象池" class="headerlink" title="重用对象——对象池"></a>重用对象——对象池</h2><h3 id="摧毁物体及优化"><a href="#摧毁物体及优化" class="headerlink" title="摧毁物体及优化"></a>摧毁物体及优化</h3><p>有了创造物体的能力后，我们就得要有摧毁物体的能力，不然就有点误区了。要实现摧毁物体。我们首先需要写一个销毁物体的方法。逻辑很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void DestroyShape () &#123;</span><br><span class="line">	if (shapes.Count &gt; 0) &#123;</span><br><span class="line">		int index = Random.Range(0, shapes.Count);</span><br><span class="line">		Destroy(shapes[index].gameObject);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处值得注意的是，shapes存储的是Shape组件，并不是一个游戏物体，因此要在后面加上Destroy(shapes[index].<em>gameObject</em>)。然后，如同之前创建物体那样，给摧毁物体也绑定一个按键，这样就实现了摧毁随即物体的功能。但是，如果我们多次按下摧毁按键，有时候反而会报错。仔细看代码就会发现：</p>
<p>我们删除的凭据是shapes中的随机物体。但是，在我们Destroy那个物体后，并没有将其移出shapes的List。这样就有可能在某次删除时，选择了某个早已被删除的物体，这样就会报错。因此，我们还需要在删除物体之后，将其编号移出shapes。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void DestroyShape () &#123;</span><br><span class="line">	if (shapes.Count &gt; 0) &#123;</span><br><span class="line">		int index = Random.Range(0, shapes.Count);</span><br><span class="line">		Destroy(shapes[index].gameObject);</span><br><span class="line">		shapes.RemoveAt(index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此，我们实现了删除物体的功能。但是，这样还不够，我们需要对其进行优化。有什么地方可以被优化呢？还是从shapes入手。</p>
<p>我们注意到，shapes是一个List。而List是由数组实现的，因此不能实现链表的操作。即：</p>
<p><img src="http://satt.oss-cn-hangzhou.aliyuncs.com/img/image-20211009125451883.png" alt="image-20211009125451883"></p>
<p>与图中的高效方法相比，我们的list反而会用逐次移动的方式来处理中间项的删除。即：</p>
<p><img src="http://satt.oss-cn-hangzhou.aliyuncs.com/img/image-20211009125547679.png" alt="image-20211009125547679"></p>
<p>这是非常低效的。因为我们目前实际上并不关心数组中物体的序号，维护这个顺序毫无意义。因此，为了加快处理速度，教程中给出了如下方法：</p>
<p><img src="http://satt.oss-cn-hangzhou.aliyuncs.com/img/image-20211009125659733.png" alt="image-20211009125659733"></p>
<p>即确定是中间项要被删除后，就把最后一个和被删除项交换。这样避免了逐次移动的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void DestroyShape () &#123;</span><br><span class="line">	if (shapes.Count &gt; 0) &#123;</span><br><span class="line">		int index = Random.Range(0, shapes.Count);</span><br><span class="line">		Destroy(shapes[index].gameObject);</span><br><span class="line">		int lastIndex = shapes.Count - 1;</span><br><span class="line">		shapes[index] = shapes[lastIndex];</span><br><span class="line">		shapes.RemoveAt(lastIndex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法，如果是我一定想不到，还需要多多思考才能发现。</p>
<h3 id="自动化生成和摧毁"><a href="#自动化生成和摧毁" class="headerlink" title="自动化生成和摧毁"></a>自动化生成和摧毁</h3><p>我们可以通过添加滑块的方式来删除和产生物体。这就是自动化！这给我们后续进行优化提供了方便。</p>
<p><img src="http://satt.oss-cn-hangzhou.aliyuncs.com/img/image-20211009130025373.png" alt="image-20211009130025373"></p>
<p>这一段代码相对简单，没啥可说的。唯一要注意的是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// false</span><br><span class="line">creationProgress += Time.deltaTime * CreationSpeed;</span><br><span class="line">		if (creationProgress &gt;= 1f) &#123;</span><br><span class="line">			creationProgress -= 1f;</span><br><span class="line">			CreateShape();</span><br><span class="line">		&#125;	</span><br><span class="line">//true</span><br><span class="line">creationProgress += Time.deltaTime * CreationSpeed;</span><br><span class="line">		while (creationProgress &gt;= 1f) &#123;</span><br><span class="line">			creationProgress -= 1f;</span><br><span class="line">			CreateShape();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要用while来代替if。因为有时候变化过于巨大，以至于-1后仍然大于1.</p>
<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p>在应用内存池后，可以让内存的调用不再那么频繁。因为内存池减少了那一瞬间的大量的垃圾回收机制的运行，因为物体实际上并没有被删除，而是被隐藏了起来，不会触发垃圾回收。如下图的对比。</p>
<p><img src="http://satt.oss-cn-hangzhou.aliyuncs.com/img/image-20211009210447274.png" alt="image-20211009210447274"></p>
<p><img src="http://satt.oss-cn-hangzhou.aliyuncs.com/img/image-20211009210520689.png" alt="image-20211009210520689"></p>
<p>为了实现内存池，我们要在shapeFactory里创建一个list，并写上创建方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Shape&gt;[] pools;</span><br><span class="line"></span><br><span class="line">	void CreatePools () &#123;</span><br><span class="line">		pools = new List&lt;Shape&gt;[prefabs.Length];</span><br><span class="line">		for (int i = 0; i &lt; pools.Length; i++) &#123;</span><br><span class="line">			pools[i] = new List&lt;Shape&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>内存池的具体思路就是，当我们创建一个物体时，首先判断内存池中还有没有对应形状的物体，如果有，就从其中激活一个物体。如果没有，那么就只能创建一个新物体。摧毁物体的时候也是同理，我们不对物体进行销毁，而是将其隐藏。具体的代码在这里省略了。</p>
<h2 id="多场景"><a href="#多场景" class="headerlink" title="多场景"></a>多场景</h2><p>我们想要让创建的物体生成在一个专门的场景中。既然物体是在运行时创建的，那么容纳它们的场景自然也是如此。也就是说，我们不能在编辑器里新建场景，而是应该用代码来创建它。</p>
<p>要实现它，我们先创建一个池场景来容纳所有可以被回收的物体实例。所有创建的物体将进入这里，并且再也不会被移出去。我们可以通过如下代码来创建一个场景。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Scene poolScene; <span class="comment">//声明的池场景</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CreatePools</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		…</span><br><span class="line">		poolScene = 	SceneManager.CreateScene(name);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，我们创建场景用的名字是当前shapefactory的名字。因此，当我们拥有多个工厂的时候，就需要注意，要给这些工厂以不同的命名。</p>
<p>有了新创建的场景，那么就需要修改代码，来让新创建的物体放在新场景下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public Shape Get (int shapeId = 0, int materialId = 0) &#123;</span><br><span class="line">	Shape instance;</span><br><span class="line">	if (recycle) &#123;</span><br><span class="line">		…</span><br><span class="line">		if (lastIndex &gt;= 0) &#123;</span><br><span class="line">			…</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			instance = Instantiate(prefabs[shapeId]);</span><br><span class="line">			instance.ShapeId = shapeId;</span><br><span class="line">			SceneManager.MoveGameObjectToScene(</span><br><span class="line">				instance.gameObject, poolScene</span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前，我们实现了效果。</p>
<p>但是仍然有一些问题。比如，在播放模式下，如果我们修改了C#代码，那么在再编译后，我们的池场景就会被弄乱。这里的原因是：</p>
<p>unity不会再次编译ScriptableObject类。也就是我们的工厂的类型。也就是说，当再编译后，我们的池场景连同内存池之类的都销毁了。那么自然，CreatePools()方法将会再次被调用，产生错误。</p>
<p>因此，我们似乎可以简单地在CreatePools方法中加上一句判断来避免这个问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (poolScene.isLoaded) &#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这不起作用，那是因为场景是一种结构体，而非引用。并且由于之前提到的不可序列化性质，所以在再编译后，我们已经丢失了poolScene的引用了。因此，我们需要再次获得它。</p>
<p>同时，我们需要注意到，我们只会在编辑器里才会出现再编译的情况，没必要在构建后的版本中如此做，因此，再加上一个当前是否在编辑器模式的判断是更好的选择。</p>
<p>此外，还有一个更隐蔽的问题，那就是，既然我们已经丢失了之前的引用，那么那些被设置为非活动状态的物体就再不能被激活了。因此，我们还需要对代码做一些修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">		<span class="keyword">if</span> (Application.isEditor) &#123;</span><br><span class="line">			poolScene = SceneManager.GetSceneByName(name);</span><br><span class="line">			<span class="keyword">if</span> (poolScene.isLoaded) &#123;</span><br><span class="line">				GameObject[] rootObjects = poolScene.GetRootGameObjects();</span><br><span class="line">                				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rootObjects.Length; i++) &#123;</span><br><span class="line">					Shape pooledShape = rootObjects[i].GetComponent&lt;Shape&gt;();</span><br><span class="line"><span class="keyword">if</span> (!pooledShape.gameObject.activeSelf) &#123;</span><br><span class="line">						pools[pooledShape.ShapeId].Add(pooledShape);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		poolScene = SceneManager.CreateScene(name);</span><br></pre></td></tr></table></figure>

<p>至此，我们终于实现了一开始的目标：在新场景中创建物体。</p>
<h3 id="多场景编辑"><a href="#多场景编辑" class="headerlink" title="多场景编辑"></a>多场景编辑</h3><p>有了一个场景，自然而然地就需要考虑多场景的问题了，这也是本章的重点。</p>
<p>在创建一个新场景后，我们将其移动到hierarchy中。值得注意的是，每个场景都有一个摄像机和光照系统，我们保留主场景的摄像头，但是光照系统则由其他的各个场景负责。</p>
<p>此处要注意，为了在构建后的版本中也能调用多个场景，我们需要在<em>File / Build Settings</em>里添加索引。</p>
<p><img src="http://satt.oss-cn-hangzhou.aliyuncs.com/img/image-20211010200710281.png" alt="image-20211010200710281"></p>
<p>在添加了索引后，我们在hierarchy中删除level 1场景也没关系了（因为我们在代码中会创建它）。</p>
<p>为了让光照系统工作正常，我们需要将LoadSceneMode设置为Additive。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void LoadLevel () &#123;</span><br><span class="line">	SceneManager.LoadScene(&quot;Level 1&quot;, LoadSceneMode.Additive);</span><br><span class="line">	SceneManager.SetActiveScene(SceneManager.GetSceneByName(&quot;Level 1&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但是只是这样还不够，因为加载场景需要一定的时间。后面的SetActiveScene方法在运行的时候，往往场景还没有加载好。因此，这就需要我们用到协程。</p>
<p>接下去还有一些细节的问题，比如判断是否加载之类的。不赘述。</p>
<h3 id="多场景切换"><a href="#多场景切换" class="headerlink" title="多场景切换"></a>多场景切换</h3><p>有了level 1，我们还需要有level 2。</p>
<p>仿照之前的做法，创建场景，在build里构建索引。</p>
<p>同时，给loadLevel方法增加参数，让他支持加载不同level。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">LoadLevel</span> <span class="params">(<span class="keyword">int</span> levelBuildIndex)</span> </span>&#123;</span><br><span class="line">	enabled = <span class="literal">false</span>;</span><br><span class="line">	yield <span class="keyword">return</span> SceneManager.<span class="built_in">LoadSceneAsync</span>(</span><br><span class="line">		levelBuildIndex, LoadSceneMode.Additive</span><br><span class="line">	);</span><br><span class="line">	SceneManager.<span class="built_in">SetActiveScene</span>(</span><br><span class="line">		SceneManager.<span class="built_in">GetSceneByBuildIndex</span>(levelBuildIndex)</span><br><span class="line">	);</span><br><span class="line">	enabled = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便我们操作，我们还需要实现按下键盘上的1、2、3、4……来实现场景的切换。这些功能的实现都和往常一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">	for (int i = 1; i &lt;= levelCount; i++) &#123;</span><br><span class="line">		if (Input.GetKeyDown(KeyCode.Alpha0 + i)) &#123;</span><br><span class="line">			StartCoroutine(LoadLevel(i));</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>支持加载不同的场景，但是我们发现，切换后的场景并不会被删除。因此还要加上如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int loadedLevelBuildIndex; // 记录当前的场景</span><br><span class="line">			if (loadedScene.name.Contains(&quot;Level &quot;)) &#123;</span><br><span class="line">				SceneManager.SetActiveScene(loadedScene);</span><br><span class="line">				loadedLevelBuildIndex = loadedScene.buildIndex;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">				IEnumerator LoadLevel (int levelBuildIndex) &#123;</span><br><span class="line">	…</span><br><span class="line">	loadedLevelBuildIndex = levelBuildIndex;</span><br><span class="line">	enabled = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	IEnumerator LoadLevel (int levelBuildIndex) &#123;</span><br><span class="line">	enabled = false;</span><br><span class="line">	if (loadedLevelBuildIndex &gt; 0) &#123;</span><br><span class="line">		yield return SceneManager.UnloadSceneAsync(loadedLevelBuildIndex);</span><br><span class="line">	&#125;</span><br><span class="line">	yield return SceneManager.LoadSceneAsync(</span><br><span class="line">		levelBuildIndex, LoadSceneMode.Additive</span><br><span class="line">	);</span><br><span class="line">	SceneManager.SetActiveScene(</span><br><span class="line">		SceneManager.GetSceneByBuildIndex(levelBuildIndex)</span><br><span class="line">	);</span><br><span class="line">	loadedLevelBuildIndex = levelBuildIndex;</span><br><span class="line">	enabled = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">				if (Input.GetKeyDown(KeyCode.Alpha0 + i)) &#123;</span><br><span class="line">				BeginNewGame();</span><br><span class="line">				StartCoroutine(LoadLevel(i));</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后，实现了多个场景的切换，我们还需要让我们的存档文件也能记录我们当前打开的是哪个场景。因此，不得不的，我们的saveVersion++了。同时，在save和load方法中添加一个新的值，用以记录场景编号。</p>
<h2 id="生成区"><a href="#生成区" class="headerlink" title="生成区"></a>生成区</h2><p>在有了多场景切换后，我们下一个需要实现或者说改进的功能就是生成物体的区域了。还记得在一开始，我们将物体随机生成的区域设定为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.localPosition = Random.insideUnitSphere * 5f;</span><br></pre></td></tr></table></figure>

<p>也就是(0,0,0)半径为5f的球体里。这是写死的数据。因此我们需要改进他。即使用生成区的概念。生成区，顾名思义就是生成物体的区域。</p>
<p>我们先创建一个新的脚本，命名为SpawnZone。并在hierarchy中新建一个物体并绑定上脚本。它将用来代表生成区。</p>
<p>在SpawnZone类中，我们返回一个点。这就是生成物体的点。它可以由一个变量控制是否生成在球体表面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Vector3 SpawnPoint</span><br><span class="line">&#123;</span><br><span class="line">    get</span><br><span class="line">    &#123;</span><br><span class="line">        return transform.TransformPoint(surfaceOnly?Random.onUnitSphere: Random.insideUnitSphere);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以通过改变spawnZone的形状来控制生成区的大小了。</p>
<p>接下去，我们在game类中创建一个对spawnZone的引用。然后修改CreateShape()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void CreateShape () &#123;</span><br><span class="line">	Shape instance = shapeFactory.GetRandom();</span><br><span class="line">	Transform t = instance.transform;</span><br><span class="line">	//t.localPosition = Random.insideUnitSphere * 5f;</span><br><span class="line">	t.localPosition = spawnZone.SpawnPoint;</span><br><span class="line">	…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，生成区毕竟是隐形的（出于各种理由，我们都不应该让玩家看到他），为了方便我们调试。我们可以使用如下代码来让其可见。即使用Gizmos.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDrawGizmos</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	Gizmos.color = Color.cyan;</span><br><span class="line">	Gizmos.matrix = transform.localToWorldMatrix;</span><br><span class="line">	Gizmos.DrawWireSphere(Vector3.zero, <span class="number">1f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://satt.oss-cn-hangzhou.aliyuncs.com/img/image-20211010212723074.png" alt="image-20211010212723074"></p>

    </div>
     
    <div class="post-footer__meta"><p>updated at 2023-05-09</p></div> 
    <div class="post-meta__cats"><a href="/tags/Uinty/" class="post-tags__link button"># Uinty</a></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/2021/11/24/eye-tracking-%E5%9C%A8VR%E7%9A%84%E5%BA%94%E7%94%A8/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            Previous Post
                        </div>
                        <div class="nav__title">
                            eye-tracking 在VR的应用
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/2021/10/07/A-%E7%AE%97%E6%B3%95%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            Next Post
                        </div>
                        <div class="nav__title">
                            A-star算法的学习
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
    


    
     
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2023 <a href="/">南方真理会</a>
        </p>
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
         

 

 

 

 

 



 


    
 


    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.css">

    
<script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.js"></script>

    <script>
        let lazyloadT = Boolean('false'),
            auto_fancybox = Boolean('true')
        if (auto_fancybox) {
            $(".post__content").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        } else {
            $(".post__content").find("fancybox").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        }
    </script>
 

 

 

 




    </body>
</html>
